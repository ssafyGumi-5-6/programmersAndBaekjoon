import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;

/* 

그림의 각 원들은 각각의 직원 1명을 표시하고 있으며, CEO를 포함하여 총 10명의 직원을 표시하고 있습니다.
원 안에 적힌 두 개의 숫자는 직원의 정보를 담고 있습니다. 왼쪽 숫자는 직원번호이며 직원을 식별할 수 있도록 1번부터 순서대로 발급되는 일련번호이며, 
오른쪽 숫자는 해당 직원의 하루평균 매출액을 나타냅니다. 위 그림에서 1번 직원은 14원을, 9번 직원은 28원의 하루평균 매출액을 기록하고 있습니다.

CEO를 포함하여 모든 직원은 팀장 또는 팀원이라는 직위를 가지고 있으며 그림에서는 팀장과 팀원의 관계를 화살표로 표시하고 있습니다. 화살표가 시작되는 
쪽의 직원은 팀장, 화살표를 받는 쪽의 직원은 팀원을 의미합니다.

3-1. 직원번호 1번은 회사의 CEO로 고정되어 있으며, CEO는 항상 팀장이고 팀원일 수 없어 화살표를 받는 쪽이 될 수 없습니다.

3-2. 반면에 CEO를 제외한 나머지 모든 직원들은 다른 누군가로부터 정확히 1개의 화살표를 받게 됩니다.

3-3. 한 직원은 최대 2개의 팀에 소속될 수 있습니다. 만약 어떤 직원이 두 개의 팀에 소속되어 있다면, 반드시 하나의 팀에서는 팀장, 나머지 팀에서는 
팀원이어야 합니다. 팀장을 겸임하거나, 두 개의 팀에서 팀원이 될 수는 없습니다. 예를들어 10번 직원은 D팀의 팀장이면서 동시에 5번 직원이 팀장으로 있는 
C팀에 속한 팀원입니다.

3-4. 5번, 9번, 10번 직원은 받는 쪽의 화살표와 시작하는 화살표가 모두 있으므로 팀장인 동시에 팀원입니다.

3-5. 2번, 3번, 4번, 6번, 7번, 8번 직원은 시작하는 화살표가 없고 받는 쪽의 화살표만 있으므로 팀장이 아니며 오직 팀원입니다.

3-6. 1번 직원인 CEO는 받는 쪽의 화살표가 없고 시작하는 화살표만 있으며 항상 팀원이 아닌 팀장입니다.

3-7. 그림의 조직도에는 A, B, C, D 총 4개의 팀이 존재하며, 각각 1번, 9번, 5번, 10번 직원이 팀장 직위를 담당하게 됩니다.

"제이지"는 자신이 구상한 새로운 사업 아이템에 대해 직원들에게 설명하고자 하루 일정으로 워크숍을 계획하고 있습니다. 
단, 모든 직원을 참석시킬 수 없어 아래와 같은 기준으로 워크숍에 참석할 직원들을 선발하려고 합니다.

- 워크숍에서 교육받은 내용은 전 직원들에게 공유되어야 하므로 모든 팀은 최소 1명 이상의 직원을 워크숍에 참석시켜야 합니다.

- 워크숍 기간 동안, 회사의 매출 손실을 최소화하는 것이 중요하므로 워크숍에 참석하는 직원들의 하루평균 매출액의 합이 최소가 되어야 합니다.

직원들의 하루평균 매출액 값을 담은 배열 sales, 직원들의 팀장-팀원의 관계를 나타내는 2차원 배열 links가 매개변수로 주어집니다. 이때, 모든 팀에서 최소 한 명 이상 워크숍에 참석하면서, 
참석하는 직원들의 하루평균 매출액의 합을 최소로 하려고 합니다. 그렇게 최소화된 매출액의 합을 구해서 return 하도록 solution 함수를 완성해 주세요.

sales	links	result
[14, 17, 15, 18, 19, 14, 13, 16, 28, 17]	[[10, 8], [1, 9], [9, 7], [5, 4], [1, 5], [5, 10], [10, 6], [1, 3], [10, 2]]	44
[5, 6, 5, 3, 4]	[[2,3], [1,4], [2,5], [1,2]]	6
[5, 6, 5, 1, 4]	[[2,3], [1,4], [2,5], [1,2]]	5
[10, 10, 1, 1]	[[3,2], [4,3], [1,4]]	2
 */

public class Solution_Programers_매출하락최소화 {
    public static void main(String[] args) {
        Solution_매출하락최소화 sol = new Solution_매출하락최소화();
        int[][] salesInput = {
            {14, 17, 15, 18, 19, 14, 13, 16, 28, 17},
            {5, 6, 5, 3, 4},
            {5, 6, 5, 1, 4},
            {10, 10, 1, 1}
        };
        int[][][] linksInput = {
            {
                {10, 8}, {1, 9}, {9, 7}, {5, 4}, {1, 5}, {5, 10}, {10, 6}, {1, 3}, {10, 2}
            },
            {
                {2,3}, {1,4}, {2,5}, {1,2}
            },
            {
                {2,3}, {1,4}, {2,5}, {1,2}
            },
            {
                {3,2}, {4,3}, {1,4}
            }
        };

        for(int i = 0; i < salesInput.length; i++) {
            System.out.println(sol.solution(salesInput[i], linksInput[i]));
        }
    }
}


class Solution_매출하락최소화 {
    public int solution(int[] sales, int[][] links) {
        int answer = 0;
        int n = sales.length;
        int m = links.length;
        int[] p = new int[n];
        HashSet<Integer> set = new HashSet<Integer>();
        List<Imp> imps = new ArrayList<>();
        for(int i = 0; i < n; i++) {
            imps.add(new Imp(sales[i]));
        }
        for (int i = 0; i < m; i++) {
            imps.get(links[i][0]).add(imps.get(links[i][1]));
            set.add(links[i][0]);
        }
        


        return answer;
    }
}

class Imp {
    int price;
    List<Imp> followers = new ArrayList<>();

    Imp(int price) {
        this.price = price;
    }

    void add(Imp imp) {
        followers.add(imp);
    }
}